--OUTER join : 조인 연결에 실패 하더라도 기준이 되는 테이블의 데이터는 나오도록 하는 join
-- LEFT OUTER JOIN : 테이블1 LEFT OUTER JOIN 테이블2
-- 테이블 1과 테이블2를 join할때 join에 실패하더라도 테이블1의 데이터는 조회가 되도록 한다.
-- join에 실패한 행에서 테이블2의 컬럼값은 존재하지 않으므로 NULL로 표시 된다.

--ANSI
SELECT e.empno, e.ename, m.empno, m.ename
FROM emp e LEFT OUTER JOIN emp m
--FROM emp e JOIN emp m
            ON e.mgr = m.empno;
            
--
SELECT e.empno, e.ename, e.deptno, m.empno, m.ename, m.deptno
FROM emp e LEFT OUTER JOIN emp m
            ON e.mgr = m.empno AND m.deptno=10;
            
SELECT e.empno, e.ename, e.deptno, m.empno, m.ename, m.deptno
FROM emp e LEFT OUTER JOIN emp m
            ON e.mgr = m.empno WHERE m.deptno=10;
            
--ORACLE outer join syntax
--일반조인과 차이점은 컬러몀에 (+) 표시
-- (+) 표시 : 데이터가 존재하지 않는데 나와야 하는 테이블의 컬럼
-- 직원 LEFT OUTER JOIN 매니저
--  ON(직원.매너저번호 = 매니저.직원번호)
-- ORACLE OUTER
-- WHERE 직원.매니저번호 = 매니저.직원번호(+) --매니저쪽 데이터가 존재하지 않음
SELECT e.empno, e.ename, m.empno, m.ename
FROM emp e, emp m
WHERE e.mgr = m.empno(+);


--매니저 부서번호 제한
--ANSI SQL 에서 WHERE 절에 기술한 형태
-- --> OUTER 조인이 적용되지 않은 상황
-- 아우터 조인이 적용되어야 되는 테이블의 모든 컬럼에 (+)가 붙어야 된다. -- > ORACLE 문법에서는
SELECT e.empno, e.ename, m.empno, m.ename
FROM emp e, emp m
WHERE e.mgr = m.empno(+)
AND m.deptno = 10;

--ANSI SQL의 on절에 기술한 경우와 동일
SELECT e.empno, e.ename, m.empno, m.ename
FROM emp e, emp m
WHERE e.mgr = m.empno(+)
AND m.deptno(+) = 10;

--emp 테이블에는 14명의 직원이 있고 14명은 10, 20, 30 부서중에 한 부서에 속한다
-- 하지만 dept 테이블에는 10, 20, 30, 40번 부서가 존재
-- 부서번호, 부서명, 해당부서에 속한 직원수가 나오도록 쿼리를 작성
select *
from emp;

-- ORACLE SQL 방식
SELECT dept.deptno, dept.dname, NVL(emp_cnt.cnt, 0) cnt FROM dept,
(SELECT deptno, count(*) cnt FROM emp GROUP BY deptno) emp_cnt
WHERE dept.deptno = emp_cnt.deptno(+)
ORDER BY dept.deptno;

-- ANSI SQL 방식
SELECT dept.deptno, dept.dname, NVL(emp_cnt.cnt, 0) cnt
FROM dept LEFT OUTER JOIN
(SELECT deptno, count(*) cnt FROM emp GROUP BY deptno) emp_cnt
ON(dept.deptno = emp_cnt.deptno);

-- ORACLE SQL 방식
SELECT dept.deptno, dept.dname, count(emp.deptno) cnt
--count(*) cnt, count(dept.deptno) cnt
FROM emp, dept
WHERE emp.deptno(+) = dept.deptno
GROUP BY dept.deptno, dept.dname
ORDER BY dept.deptno;

-- 방향성을 따짐
--
SELECT e.empno, e.ename, m.empno, m.ename
FROM emp e LEFT OUTER JOIN emp m
            ON e.mgr = m.empno;
            
SELECT e.empno, e.ename, m.empno, m.ename
FROM emp e RIGHT OUTER JOIN emp m
            ON e.mgr = m.empno;
            
--FULL OUTER : LEFT OUTER + RIGHT OUTER - 중복데이터 한건만 남기기

-- (outer join 실습 outerjoin 1)
select * from buyprod;
select * from prod;

-- (oracle 방식)
SELECT a.buy_date, a.buy_prod, b.prod_id, b.prod_name, a.buy_qty
FROM buyprod a, prod b
WHERE a.buy_prod(+) = b.prod_id
AND a.buy_date(+) = to_date('20050125', 'yyyymmdd');

-- (ANSI 방식)
SELECT a.buy_date, a.buy_prod, b.prod_id, b.prod_name, a.buy_qty
FROM buyprod a RIGHT OUTER JOIN prod b ON a.buy_prod = b.prod_id 
AND a.buy_date = to_date('20050125', 'yyyymmdd');

-- (outer join 실습 outerjoin 2)

--(ANSI 방식)
SELECT c.* FROM(SELECT NVL(a.buy_date, '2005/01/25'), a.buy_prod, b.prod_id, b.prod_name, a.buy_qty
FROM buyprod a RIGHT OUTER JOIN prod b ON a.buy_prod = b.prod_id
AND TO_DATE(TO_CHAR(a.buy_date, 'YY/MM/DD'), 'YY/MM/DD') = '20050125')c;

-- (outer join 실습 outerjoin 3)

--(ANSI 방식)
SELECT c.* FROM(SELECT NVL(a.buy_date, '2005/01/25'), a.buy_prod, b.prod_id, b.prod_name, NVL(a.buy_qty, 0)
FROM buyprod a RIGHT OUTER JOIN prod b ON a.buy_prod = b.prod_id
AND TO_DATE(TO_CHAR(a.buy_date, 'YY/MM/DD'), 'YY/MM/DD') = '20050125')c;

-- (outer join 실습 outerjoin 4)
select * from cycle;
select * from product;
--(ANSI 방식)
SELECT b.pid, b.pnm, NVL(a.cid, 1) cid, NVL(a.day, 0) day, NVL(a.cnt, 0) cnt 
FROM cycle a RIGHT OUTER JOIN product b ON a.pid = b.pid AND a.cid = 1;

-- (outer join 실습 outerjoin 5)
select * from cycle;
select * from product;
select * from customer;

--(ANSI 방식)
SELECT b.pid, b.pnm, NVL(a.cid, 1) cid, NVL(c.cnm, 'brown') cnm, NVL(a.day, 0) day, NVL(a.cnt, 0) cnt 
FROM cycle a RIGHT OUTER JOIN product b ON a.pid = b.pid AND a.cid = 1 LEFT OUTER JOIN customer c ON a.cid = c.cid ORDER BY b.pid desc;

-- oracle 방식
SELECT a.pid, a.pnm, a.cid, customer.cnm, a.day, a.cnt FROM
(SELECT product.pid, product.pnm,
        :cid cid, NVL(cycle.day, 0) day, NVL(cycle.cnt, 0) cnt
        FROM cycle, product
        WHERE cycle.cid(+) = :cid
        AND cycle.pid(+) = product.pid) a, customer
WHERE a.cid = customer.cid;