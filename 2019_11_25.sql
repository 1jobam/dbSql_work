-- RDBMS - SQL 표준 문법이 있기때문에 활용 하기 편하다.
-- NOSQL - 표준이 없기 때문에 제품군 마다 문법이나 사용법이 다르다 (API)

-- emp 테이블에서 ROWNUM 값이 1~10인 값만 조회하는 쿼리를 작성해보세요.
-- (정렬없이 진행하세요.)
select rownum, empno, ename from emp where rownum between 1 and 10;
-- row_2
select a.* from (select rownum ab, empno, ename from emp) a where ab between 11 and 14;
-- row_3
select * from(select rownum ra , a.* from(select ename, empno from emp order by ename) a) where ra between 11 and 14;

--DUAL 테이블 : sys 계정에 있는 누구나 사용가능한 테이블이며 
--데이터는 한행만 존재하며 컬럼(dummy)도 하나 존재 'x')

select * from dual;

--SINGLE ROW FUNCTION : 행당 한번의 FUNCTION이 실행
-- 1개의 행 INPUT -> 1개의 행으로 OUTPUT (COLUM)
-- 'Hello, world'
SELECT LOWER('Hello, world') FROM DUAL;
SELECT UPPER('Hello, world') FROM DUAL;
SELECT LOWER('Hello, world')  low , UPPER('Hello, world') upper , INITCAP('Hello, world')  FROM DUAL;

--emp테이블에는 총 14건의 데이터(직원)가 존재 (14개의 행)
-- 아래 쿼리는 결과도 14개의 행
SELECT LOWER('Hello, world') low , UPPER('Hello, world') upper , INITCAP('Hello, world') FROM emp;

--컬럼에 function 적용
SELECT empno, LOWER(ename) low_enm FROM emp WHERE ename = upper('smith'); -- 직원 이름이 smith인 사람을 조회 하려면 대문자/소문자?

-- 테이블 컬럼을 가공해도 동일한 결과를 얻을 수 있지만
-- 테이블 컬럼 보다는 상수쪽을 가공하는 것이 속도면에서 유리
-- 해당 컬럼에 인덱스가 존재하더라도 함수를 적용하게 되면 값이 달라지게 되어
-- 인덱스를 활용 할 수 없게 된다.
-- 예외 : FBI(Function Based Index)
SELECT empno, LOWER(ename) low_enm FROM emp WHERE LOWER(ename) = 'smith'; -- 테이블쪽 컬럼은 가공하면 안된다. (7거지악)

select upper('smith') from dual;

--HELLO
--,
--WORLD
--HELLO, WORLD (위 3가지 문자열 상수를 이용, CONCAT 함수를 사용하여 문자열 결합)
SELECT CONCAT(CONCAT('HELLO', ', '), 'WORLD') c1,
       CONCAT('HELLO', ', '),
       'HEELO' || ', ' || 'WORLD' c2,
       
       --시작인덱스는 1부터, 종료인덱스 문자열까지 포함 한다.
       SUBSTR('HEELO, WORLD', 1, 5) s1, -- SUBSTR(문자열, 시작인덱스, 종료인덱스)
       
       --INSTR : 문자열에 특정 물자열이 존재하는지, 존재할 경우 문자의 인덱스를 리턴
       INSTR('HELLO, WORLD', 'O') i1, --5, 9
       --'HELLO, WORLD' 문자열의 6번째 인덱스 이후에 등장하는 'O'문자열의 인덱스 리턴
       INSTR('HELLO, WORLD', 'O', 6) i2, --INSTR은 문자열의 특정 인덱스 이후부터 검색 하도록 옵션을 줄수 있다.
       
       INSTR('HELLO, WORLD', 'O', INSTR('HELLO, WORLD', 'O') + 1) i3, --INSTR은 문자열의 특정 인덱스 이후부터 검색 하도록 옵션을 줄수 있다.
       
       --L/RPAD 특정 문자열의 왼쪽/오른쪽에 설정한 문자열 길이보다 부족한 만큼 문자열을 채워 넣는다.
       LPAD('HELLO, WORLD', 15, '*')L1,
       LPAD('HELLO, WORLD', 15)L2, --DEFAULT로 채우는 문자는 공백이다.
       RPAD('HELLO, WORLD', 15, '*')R1,
       RPAD('HELLO, WORLD', 15)R2,
       
       --REPLACE(대상문자열, 검색 문자열, 변경할 문자열)
       --대상문자열에서 검색 문자열을 변경할 문자열로 치환
       REPLACE('HELLO, WORLD', 'HELLO', 'hello') rep1, --hello, WORLD
       
       --문자열 앞, 뒤의 공백을 제거
        '   HELLO, WORLD   ' before_trim,
       TRIM('   HELLO, WORLD   ') after_trim,
       TRIM( 'H' FROM 'HELLO, WORLD') after_trim2
       
--FROM  dual;
from dept;
--dual 가상 테이블 활용 연습 해보기

--숫자 조작함수
--ROUND : 반올림 - ROUND(숫자, 반올림 자리)
--TRUNC : 절삭 - TRUNC(숫자, 절삭 자리)
--MOD : 나머지 연산 - MOD(피제수, 제수) // MOD(5, 2) : 나머지는 1

SELECT --반올림 결과가 소수점 한자리까지 나오도록(소수점 둘째자리까지 반올림)
        ROUND(105.54, 1) r1, -- 0.00 -> 0.0
        ROUND(105.55, 1) r2, -- 0.00 -> 0.0
        ROUND(105.55, 0) r3, -- 소수점 첫번째 자리에서 반올림 0.0 -> 0
        ROUND(105.55, -1) r4 -- 정수 첫번째 자리에서 반올림 105 -> 110
FROM dual;

SELECT -- 절삭 결과가 소수점 한자리까지 나오도록(소수점 둘째자리까지 절삭) DEFAULT = 0입니다.
        TRUNC(105.54, 1) t1, 
        TRUNC(105.55, 1) t2, 
        TRUNC(105.55, 0) t3, --소수점 첫번째 자리에서 절삭
        TRUNC(105.55, -1) t4 -- 정수 첫번째 자리에서 절삭
FROM dual;

--MOD(피제수, 제수) 피제수를 제수로 나눈 나머지 값
--MOD(M, 2) 의 결과 종류 : 0, 1( 0 ~ 제수 - 1 )
SELECT MOD(5, 2) m1 -- 5/2 = 1 : 몫이 2, [나머지가 1]
from dual;

--emp 테이블의 sal 컬럼을 1000으로 나눴을때 사원별 나머지 값을 조회 하는 sql 작성
-- ename, sal, sal/1000을 때의 나머지
SELECT ename, sal, TRUNC(sal/1000) 몫, MOD(sal, 1000) 나머지, TRUNC(sal, 1000) * 1000 + MOD(sal, 1000) sal2 FROM emp;

--DATE : 년월일, 시간, 분, 초
SELECT ename, hiredate, TO_CHAR(hiredate, 'YYYY/MM/DD hh24:mi:ss') --YYYY/MM/DD 
FROM emp;

--SYSDATE : 서버의 현재 DATE를 리턴하는 내장함수, 특별한 인자가 없다.
--DATE 연산 DATE + 정수N = DATE N일자 만큼 더한다.
--DATE 연산에 있어서 정수는 일자
--하루는 24시간
--DATE 타입에 시간을 더할 수 도 있다. 1시간 = 1/24
SELECT TO_CHAR(SYSDATE + 5, 'YYYY-MM-DD hh24:mi:ss') AFTER5_DAYS,
        TO_CHAR(SYSDATE + 5/24, 'YYYY-MM-DD hh24:mi:ss') AFTER5_HOURS,
        TO_CHAR(SYSDATE + 5/24/60, 'YYYY-MM-DD hh24:mi:ss') AFTER5_MIN,
        TO_CHAR(SYSDATE + 5/24/60/60, 'YYYY-MM-DD hh24:mi:ss') AFTER5_SS
        
        --1시간 : 3600초
FROM dual;

-- Funtion(date 실습 fn1)
-- 1. 2019년 12월 31일을 date 형으로 표현
-- 2. 2019년 12월 31일을 date 형으로 표현하고 5일 이전 날짜
-- 3. 현재 날짜
-- 4. 현재 날짜에서 3일 전 값.
-- 위 4개 컬럼을 생성하여 다음과 같이 조회하는 쿼리를 작성하세요.
SELECT TO_DATE('20191231', 'YY/MM/DD') LASTDAY,  -- 원하는 날짜를 원하는 형식으로 변경
        TO_DATE('20191231', 'YY/MM/DD') - 5 LASTDAY_BEFORE5,
        TO_CHAR(sysdate, 'YY/MM/DD') NOW, -- 형식을 변경후 현재 시각
        TO_CHAR(sysdate - 3, 'YY/MM/DD') NOW_BEFORE3
FROM dual;

--YYYY, MM, DD, D(요일을 숫자로 : 일요일 1, 월요일 2, 화요일 3......토요일 : 7)
--IW(주차 1 ~ 53), HH, MI, SS
SELECT TO_CHAR(SYSDATE, 'YYYY') YYYY -- 현재년도
    , TO_CHAR(SYSDATE, 'MM') MM -- 핸재월
    , TO_CHAR(SYSDATE, 'DD') DD -- 현재일
    , TO_CHAR(SYSDATE, 'D') D -- 현재요일
    , TO_CHAR(SYSDATE, 'IW') IW -- 현재년도의 현재주차
    --2019년 12월 31일은 몇주차가 나오는가?
    ,TO_CHAR(TO_DATE('20191231', 'YYYY_MM_DD'),'IW') -- 원하는 년도의 원하는 날이 몇주차인지 확인
FROM dual;

-- Function (date 실습 fn2)
-- 오늘 날짜를 다음과 같은 포맷으로 조회하는 쿼리를 작성하시오
-- 년-월-일
-- 년-월-일 시간(24)-분-초
-- 일-월-년
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') DT_DASH,  
        TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24-MI-SS') DT_DASH_WITH_TIME,
        TO_CHAR(SYSDATE, 'DD-MM-YYYY') DT_DD_MM_YYYY
FROM dual;

--DATE 타입의 ROUND, TRUNC 적용
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD hh24:mi:ss') now
        --MM에서 반올림 (11월 -> 1년)
        ,TO_CHAR(ROUND(SYSDATE, 'YYYY'), 'YYYY-MM-DD hh24:mi:ss') now_YYYY
        
        --DD에서 반올림 (24일 -> 1개월)
        ,TO_CHAR(ROUND(SYSDATE, 'MM'), 'YYYY-MM-DD hh24:mi:ss') now_MM
        
        --시간에서 반올림
        ,TO_CHAR(ROUND(SYSDATE, 'DD'), 'YYYY-MM-DD hh24:mi:ss') now_DD
FROM dual;

SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD hh24:mi:ss') now
        --MM에서 절삭 (11월 -> 1월)
        ,TO_CHAR(TRUNC(SYSDATE, 'YYYY'), 'YYYY-MM-DD hh24:mi:ss') now_YYYY
        
        --DD에서 절삭 (11월 24일 -> 11월 1일)
        ,TO_CHAR(TRUNC(SYSDATE, 'MM'), 'YYYY-MM-DD hh24:mi:ss') now_MM
        
        --시간에서 절삭 ( 현재시간 -> 0시 )
        ,TO_CHAR(TRUNC(SYSDATE, 'DD'), 'YYYY-MM-DD hh24:mi:ss') now_DD
FROM dual;


--날짜 조작 함수
--MONTHS_BETWEEN(date1, date2) : date2와 date1 사이의 개월 수
--ADD_MONTHS(date, 가감한 개월수) : date에서 특정 개월수를 더하거나 뺀 날짜
--NEXT_DAY(date, weekday(1~7)) : date이후 첫 번째 weekday 날짜
--LAST_DAY(date) : date가 속한 월의 마지막 날짜

--MONTHS_BETWEEN (date1, date2)
SELECT MONTHS_BETWEEN(TO_DATE('2019-11-25', 'YYYY-MM-DD'), TO_DATE('2019-03-31', 'YYYY-MM-DD')) m_bet
    , TO_DATE('2019-11-25', 'YYYY-MM-DD') - TO_DATE('2019-03-31', 'YYYY-MM-DD') d_m --두 날짜 사이의 일자수
FROM dual;

--ADD_MONTHS(date, number(+,-) )
SELECT ADD_MONTHS(TO_DATE('20191125', 'YYYYMMDD'), 5) NOW_AFTER5M
        ,ADD_MONTHS(TO_DATE('20191125', 'YYYYMMDD'), -5) NOW_BEFORE5M
        , SYSDATE + 100 --100일 뒤의 날짜 (월 개념 3-31, 2-28/29)
FROM dual;

--NEXT_DAY(date, weekday number(1~7))
SELECT NEXT_DAY(SYSDATE, 5) --오늘 날짜(2019/11/25)일 이후 등장하는 첫번째 토요일
FROM dual;















